import { newServer } from 'mock-xmlhttprequest';
import { Channels } from '../Channels';
import { CreateSound } from '../types';

export const mockXMLHttpRequest = () => {
  const server = newServer({
    get: [
      () => true,
      {
        status: 200,
        body: new ArrayBuffer(10000000),
      } as any,
    ],
  });
  server.install();
};

export const createMockChannelsInstance = (sounds?: Array<CreateSound>) => {
  const channelsInstance = new Channels({
    soundsPath: 'path',
    soundsExtension: 'mp3',
    sounds,
  });

  // sets a default audiobuffer for loaded sounds
  (channelsInstance.audioContext as any).DECODE_AUDIO_DATA_RESULT =
    channelsInstance.audioContext.createBuffer(2, 44100, 44100);

  return channelsInstance;
};

export const getAudioGraph = (channels: Channels) =>
  (channels.audioContext as any).toJSON();

type SimpleAudioGraphNode = {
  name: string;
  inputs: Array<SimpleAudioGraphNode>;
  outputs: Array<SimpleAudioGraphNode>;
  gain?: { value?: number };
};

/**
 * Gets a flattened list of the graph generated by getAudioGraph(),
 * by recursively grabbing each node connected to the input of the given node.
 * Throws an error if an input has more than one connection.
 * @param jsonGraph
 * @param chain
 */
export const getNodeChain = (
  jsonGraph: SimpleAudioGraphNode,
  chain: Array<SimpleAudioGraphNode> = []
): Array<SimpleAudioGraphNode> => {
  if (jsonGraph.inputs.length === 0) {
    return chain;
  } else if (jsonGraph.inputs.length === 1) {
    return getNodeChain(jsonGraph.inputs[0], [...chain, jsonGraph.inputs[0]]);
  } else {
    throw new Error(`Node ${jsonGraph.name} has more than one input.`);
  }
};
